# 리스트 컴프리헨션에서 표현식을 두 개 넘게 쓰지 말자

리스트 컴프리헨션은 중첩해서 사용하는 것도 가능하다.

아래와 같이 2차원 리스트 행렬을 하나의 리스트로 만들 수 있다.
```py
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
print(flat)

>>>
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

이 표현식은 아래와 같은 순서로 실행된다.
1. for row in matrix
2. for x in row
3. 이제 x는 matrix의 원소 하나가 된다.

행렬의 각 원소를 제곱하여 그대로 다시 행렬을 만들 때도 컴프리헨션을 중첩하여 사용할 수 있다.
```py
squared = [[x ** 2 for x in row] for row in matrix]
print(squared)

>>>
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]
```

이 정도의 컴프리헨션의 중첩된 사용은 용인할만하다. 이보다 더 복잡한 예제를 보면 다음과 같은 예가 있을 수 있다.
```py
my_lists = [
    [[1, 2, 3], [4, 5, 6]],
    [[7, 8, 9], [10, 11, 12]]
]

flat = [x for sublist1 in my_lists for sublist2 in sublist1 for x in sublist2]
print(flat)

>>>
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

이 경우에는 일반 루프문이 훨씬 이해하기 쉽다.
```py
flat = []
for sublist1 in my_lists:
    for sublist2 in sublist1:
        flat.extend(sublist2)

print(flat)

>>>
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

리스트 컴프리헨션은 다중 if 조건을 지원한다. 같은 루프 레벨에 여러 조건문이 있으면 암시적으로 AND로 연결된다. 아래 예제의 b와 c는 같은 값을 가진 리스트이다.
```py
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = [x for x in a if x > 4 if x % 2 == 0]
c = [x for x in a if x > 4 and x % 2 == 0]

print(a)
print(b)
print(c)

>>>
[6, 8, 10]
[6, 8, 10]
```

조건을 포함한 리스트 컴프리헨션을 중첩한다면 간단하게 코드를 작성할 수 있어도 이해하기가 어려워진다.

```py
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
filtered = [[x for x in row if x % 3 == 0] for row in matrix if sum(row) >= 10]
print(filtered)

>>>
[[6], [9]]
```

이런 코드를 적용하기에 적합한 경우를 마주치게 되겠지만 되도록 이런 방식의 사용은 피하는 것이 좋다. 몇 줄을 절약한 장점이 나중에 겪을 어려움보다 크지 않다.

리스트 컴프리헨션을 사용할 때는 표현식이 두 개를 넘어가면 피하는 게 좋다. __조건 두 개, 루프 두 개__ 혹은 __조건 한 개와 루프 한 개 정도__면 된다. 이것보다 복잡해지면 일반적인 if, for 문을 이용하고 헬퍼 함수를 사용하는 것이 좋다.

## 정리
1. 리스트 컴프리헨션은 다중 루프 및 루프 레벨별 다중 조건을 지원한다.
2. 표현식이 두 개 이상 들어가 있는 리스트 컴프리헨션은 가독성이 떨어지므로 피하는 것이 좋다.