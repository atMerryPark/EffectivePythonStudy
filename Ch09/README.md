# 컴프리헨션이 클 때는 제너레이터 표현식을 고려하자

리스트 컴프리헨션은 새 리스트를 통째로 만드는데 이것이 때때로 문제가 된다.

예를 들어 파일에 오류가 있거나 끊김이 없는 네트워크 소켓일 경우 리스트 컴프리헨션을 사용하면 문제가 될 수 있다. 다음 예제는 입력 값이 적은 경우만 처리할 수 있는 방식으로 리스트 컴프리헨션을 사용한 예다.
```py
value = [len(x) for x in open('my_file.txt')]
print(value)

>>>
[31, 34, 31, 36, 28, 29, 20, 56, 36, 35, 28, 58, 70, 67, 26, 49, 59, 65, 64]
```

파이썬은 이러한 문제를 해결하기 위해서 리스트 컴프리헨션과 제너레이터를 일반화한 제너레이터 표현식을 제공한다. 제너레이터 표현식은 실행될 때 출력 시퀀스를 모두 생성하지 않고 한 번에 한 아이템을 얻을 수 있는 이터레이터로 평가된다.

제너레이터 표현식의 문법은 아래와 같다.
```py
it = (len(x) for x in open('my_file.txt'))
print(it)

>>>
<generator object <genexpr> at 0x02083780>
```

제너레이터 표현식에서 다음 값을 얻으려면 내장 함수 next를 호출하면 된다.
```py
print(next(it))
print(next(it))

>>>
31
34
```

제너레이터 표현식은 리스트 컴프리헨션처럼 다른 제너레이터 표현식과 사용할 수 있다.
```py
root = ((x, x ** 5) for x in it)
print(next(root))

>>>
(31, 28629151)
```

이처럼 제너레이터를 연결하면 큰 입력 스트림에서 동작하는 기능을 파이썬에서 매우 빠르게 실행할 수 있다. 다만 제너레이터 표현식이 반환한 이터레이터에는 상태가 있으므로 이터레이터를 한번에 넘게 사용하지 않아야 한다.( Ch17 참고 )

## 정리
1. 리스트 컴프리헨션은 큰 입력에 대해서 많은 메모리를 사용하여 문제가 될 수 있다.
2. 제너레이터 표현식은 출력을 이터레이터로 만들어 메모리 문제를 회피할 수 있다.
3. 제너레이터 표현식을 다른 제너레이터 표현식의 내부에서 사용하여 조합할 수 있다.